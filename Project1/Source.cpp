/*Это главный файл с кодом программы, ниже подключаются библиотеки и другие файлы*/
#include <iomanip>
#include <iostream>                                 //для работы с файлами
#include <fstream>                                  //тоже
#include <math.h>                                   //для нестандартных матиматических операций
#include <vector>                                   //для возможности использовать векторы, т.к они удобнее массивов
#include <ctime>                                    //для работы со временем
#include "glut.h"                                   //графика
#include "glaux.h"                                  //тоже
#include <chrono>                                   //для работы со временем

//пользовательские библиотеки, которые ТЫ САМ написал
#include "move.h"                                   //пользовательская библиотека для управления визуализацией с клавиатуры
#include "image.h"                                  //пользовательская библиотека для отрисовки графики

//кусок, отвечающий за то, чтоб библиотеки не подгружались рекурсивно
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glut32.lib")
#pragma comment(lib, "glaux.lib")
 
using namespace std;                                // рабочее пространство имен

//начало нашего кода                                //объявляем глбальные переменные

int bx, by, cx, cy, px, py;                         //координаты препятствий, городов, точек, соответственно
bool Lblock[10000], Sblock[10000];                  // ДРП (дискретное рабочее поле) логическое
int Lpath[10000], Spath[10000];                     //тоже, только цифровое
const int MAX_value=10000000;                       //переменная, для сравнения


int count_city, count_barrier, count_point;         //счетчики количества городов, препятствий и точек для рандомайзера

class Timer {                                       //класс для замера времени, его я описывать не буду, т.к это уже сложные конструкции ООП, если будет надо, то расскажу
private: 
    using clock_t = chrono::high_resolution_clock;
    using second_t = chrono::duration<double, std::ratio<1> >;
    chrono::time_point<clock_t> m_beg;
public:
    Timer() : m_beg(clock_t::now()) {}
    void reset() { m_beg = clock_t::now(); }
    double elapsed() const {
        return chrono::duration_cast<second_t>(clock_t::now() - m_beg).count();
    }
};

//векторы это аналоги массивов, обладающие бОльшим удобством, т.к могут менять размер и имеют много крутых встроенных функций
//веторы для хранения координат точек, городов и препятствий по х и у, соответственно
vector<int> point_x_pos;
vector<int> point_y_pos;

vector<int> city_x_pos;
vector<int> city_y_pos;

vector<int> barrier_x_pos;
vector<int> barrier_y_pos;

int p_opt_x, p_opt_y;                                                                   //координаты оптимальной точки

void print_termenal_and_barrier();
void print_DRP();
void Print_newDRP(char Sboard[1000][1000]);
void RenderScene();

//функция нахождения расстония от точки до ближайшего к ней города
int dist_to_city(int p_x, int p_y, vector<int> c_x, vector<int> c_y) {                  //входные данные это координаты рассматриваемой точки и векторы с координатами всех городов             

    int dist_all = MAX_value;                                                           //объявляем, что минимальное расстояние равно огромному значению
    for (int i = 0; i < c_x.size(); i++) {                                              //циклом перебираем координаты всех городов
        /* на каждой итерации (вот тебе и итерационный алгоритм)
        находим манххэттеновское расстояние (то есть рассояние по 
        горизонтале и вертикале) между точкой и городом. Сравниваем
        это расстояние с минимальным (а оно у нас на первой итерации = 10000000,
        то есть первое найденное растояние будет точно меньше)
        Если оно меньше минимального, то объявляем, что теперь это минимальное
        расстояние. таким образом при переборе всех координат городов
        мы найдем ближайший город и расстояние до него. Функция возвращает
        значение равное расстоянию до ближайшего города
        */
        if (abs(p_x - c_x[i]) + abs(p_y - c_y[i]) < dist_all) {                         //перебираем коор-ты всех городов и сравниваем расстоние до них с минимальным расстоянием на данной итерации              
            dist_all = abs(p_x - c_x[i]) + abs(p_y - c_y[i]);                           //объявляем найденное расстояние минимальным, если оно меньше минимального.найденного ранее
        }
    }
    return dist_all;                                                                    //возвращаемое значение
}

//фунция нахождения расстояния до ближайшего препятствия
int dist_to_barier(int p_x, int p_y, vector<int> b_x, vector<int> b_y) {                //входные данные это координаты рассматриваемой точки и векторы с координатами всех препятствий
    int dist_all = MAX_value;
    /*ллогика работы точно такая же, что и в предыдущей функции, только
    теперь мы рассматриваем координаты препятствий вместо коор-т городов.
    Описывать не буду, все точно также. Выходными данными является расстоние 
    от точки до ближайшего препятствия*/
    for (int i = 0; i < b_x.size(); i++) {
        if (abs(p_x - b_x[i]) + abs(p_y - b_y[i]) < dist_all) {
            dist_all = abs(p_x - b_x[i]) + abs(p_y - b_y[i]);
        }
    }
    return dist_all;
}

int main(int argc, char* argv[])                                                         //Это основная (головная) функция программы, она является точкой входа в программу
{
    setlocale(LC_ALL, "Russian");                                                        //говорим о том, что в проге используется русский язык. Это нужно для корректного отображения русского текста в консоле (и не только)

    int answer = 0;                                                                      //объявляем переменную, которая будет использоваться для выбора режима
    cout << endl << "Способы получения входных данных:"                                   //выводим инфу о режимах получения данных
        << endl << "1) Координаты генерируются случайно исходя из ограничений, введенных пользователем"
        << endl << "2) Кооридаты считываются из файла";

    cout<<endl << endl << "Введите номер выбранного способа: ";
    cin >> answer;                                                                      //получаем от пользователя число

    if (answer == 1) {                                                                  //если получаем 1, то попадаем сюда
        //просим пользователя ввести некиезначения

        cout << "Введите размер ДРП: "; 
        cin >> n;                                                                       //получаем размер ДРП
        cout << endl << "Ведите количество препятствий: ";
        cin >> count_barrier;                                                           //получаем кол-во препятствий
        cout << endl << "Введите количество городов: ";
        cin >> count_city;                                                              //получаем кол-во городов
        cout << endl << "Введите количество точек: ";
        cin >> count_point;                                                             //получаем кол-во точек

        for (int i = 0; i < n; i++)                                                     //на основе полученного размера создаем ДРП такого размера (двойной массив)
        {
            for (int j = 0; j < n; j++)
            {
                Lboard[i][j] = '0';                                                     //санчала заполняем его нулями потому что пока все пусто)
                Sboard[i][j] = '0';
            }
        }

        for (int i = 0; i < count_barrier; i++) {                                       //основываясь на количестве препятствий создаем столько препятствий
            bx = rand() % n;                                                            //коор-ты по х и у задаеются случайные
            by = rand() % n;                                                            // % n означает , что диапазон случайных чисел лежит от 0 до n.
                                                                                        // в данном случае он нужен для того, чтоб координаты формировались только в пределе ДРП
            barrier_x_pos.push_back(bx);                                                //добавляем коор-ты в вектор коор-т препятствий по х
            barrier_y_pos.push_back(by);                                                //аналогично по у
            Lboard[bx][by] = '#';                                                       //расставляем препятствия на ДРП, для этого обозначем их специальным символом #
            Sboard[bx][by] = '#';
        }

        /*Здесь мы используем цикл while потому что не знаем, сколько итераций придется сделать */
        while (city_x_pos.size() != count_city) {                                       //цикл будет выполняться, пока в векторе коор-т городов не будет столько же знаечений сколько ввел пользователь
            /*В данном цикле будут проводиться проверки на то, что полученные координаты не заняты
            Для этого ввдятся доп локальные переменные х и у*/
            int x, y;                                                                   
            x = rand() % n;                                                             //присваиваем коор-там случайное згачение в пределе размеров ДРП
            y = rand() % n;
            if (Sboard[x][y] == '0' && Lboard[x][y]=='0') {                             //Здесь мы проверяем, не заната ли клетка с такими координатами
                                                                                        //если не занято то выполняем следующие действия
                cx = x;                                                                 //присваиваем полученные коор-ты
                cy = y;
                city_x_pos.push_back(cx);                                               //добавляем эти поор-ты в вектор коор-т городов по х
                city_y_pos.push_back(cy);                                               // и по у
                Lboard[cx][cy] = 'C';                                                   //расставляем препятствия на ДРП, для этого обозначем их специальным символом С
                Sboard[cx][cy] = 'C';
            }
            //Если эта клетка уже занята, то повторяем итерацию и получаем новые случайные значения
            //Так будет продолжаеться, пока не будут получены подходящие незанятые коор-ты
            //(На самом деле, если ты задаешь размер ДРП ,например, 2, а кол-во городов и претяпствий 10, то прога зависнет из-за этого цикла, так что не делай так)
        }

        //аналогично прошлому циклу используем while т.к не знаем заранее кол-во итераций
        //В принципе, здесь все тоже самое
        while (point_x_pos.size() != count_point) {
            int x, y;
            x = rand() % n;                                                              //случайные значения получаем
            y = rand() % n;
            if (Sboard[x][y] == '0' && Lboard[x][y] == '0') {                            //проверяем, что клетка с такими координатами свободна
                px = x;                                     
                py = y;
                point_x_pos.push_back(px);                                               //если да, то добавляем эти коор-ты в векторы
                point_y_pos.push_back(py);                                               //Помечаем на ДРП символом Р
                Lboard[px][py] = 'P';
                Sboard[px][py] = 'P';
            }
        }

    }

    //Сюда мы попадем если пользователь при выборе режима ввода данных нажмет 2
    else if (answer == 2) {
        ifstream in("input.txt");                                                               //объявляем объект (переменную) являющийся объектом потокового ввода из файла
        //некая проверка на возможность откыть файл
        //это не обязательно, но это является правилом хорошего тона
        if (!in.is_open()) {                                                                    //проверяем, можно ли открыть это файл (Может быть так, что файдла не существует)  
            cout << "Файл не может быть открыт!\n";                                             //если файл открыть невозможно, то сообщаем об этом пользователю и закрываем программу
            return ERROR_FILE_NOT_FOUND;                                                        //директива ошибки открытия файла (файл не найден)
        }
        else {                                                                                  //если файл найден, то читаем данные из него

            in >> n;                                                                            //читаем размер ДРП (оно будет только квадратным)
            /*Создаем наше ДРП путем заполнения 0 (0 - пустое место)
            Т.к ДРп представляет собой двой массив (матрицу), то
            заполнение происходит в двойном цикле - по строчно*/
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    Lboard[i][j] = '0';                                                         //изначально все ячейки ДРП делаем пустыми
                    Sboard[i][j] = '0';
                }
            }

            in >> count_barrier;                                                                //читаем кол-во препятствий
            for (int i = 0; i < count_barrier; i++) {
                in >> bx >> by;                                                                 //читаем коор-ту каждого препятствия по х и у
                barrier_x_pos.push_back(bx);                                                    //добавляем коор-ту по х в вектор коор-т препятствий по х
                barrier_y_pos.push_back(by);                                                    //аналогично только по у
                Lboard[bx][by] = '#';                                                           //расставляем препятствия на ДРП, для этого обозначем их специальным символом #
                Sboard[bx][by] = '#';
            }

            in >> count_city;                                                                   //читаем кол-во городов
            for (int i = 0; i < count_city; i++) {
                in >> cx >> cy;                                                                 //здесь все аналогично с препятствиями
                city_x_pos.push_back(cx);
                city_y_pos.push_back(cy);
                Lboard[cx][cy] = 'C';
                Sboard[cx][cy] = 'C';
            }

            in >> count_point;                                                                   //читаем кол-во точек
            for (int i = 0; i < count_point; i++) {
                in >> px >> py;                                                                  //тоже аналогично
                point_x_pos.push_back(px);
                point_y_pos.push_back(py);
                Lboard[px][py] = 'P';
                Sboard[px][py] = 'P';
            }
        }
    }
    else {                                                                                  //Если пользователь ввел не 1 и не 2 на этапе выбора режима, то принимаем это за некооректные данные
        cout << endl << "Введены некорректные данные. Завершение программы";                //сообщаем об этом
        return ERROR_INVALID_DATA;                                                          //возвращаем директиву ошибки некорректных данных
    }
    //На этом получение данных закончено
    if(n<=30) print_termenal_and_barrier();
    //выводим наше ДРП после расстановки всех препятствий, городов и точек
    //эта функция описана в другом файле
    //здесь введена проверка на размер дрп, если оно больше 30, то в консоль оно выведено не будет, т.к это занимает большое кол-во времени
    cout << endl << endl;                                               

    int min_dist_p_to_c = MAX_value;                                                        //объявляем что минимальное расстояние = огромному числу
    int max_dist_p_to_b = 0;                                                                //максимальное расстояние ранво 0

    Timer t;                                                                                //объект класса времени (нужно для оценки времени). Точка начала отсчета времени работы алгоритма

    //тут вот довольно сложная для визуального восприятия конструкция... если надо, могу упростить
    //Это и есть твой главый алгорим
    /*в цикле перебираем все точки
    для каждой точки с помощью двух функций описанных выше
    находим расстояние для ближайшего города
    и ближайшего препятствия. находим точку, удовлетворяющуую
    2 условиям:
    1) расстояние от точки до ближайшего препятствия максимально
    2) расстояние до ближайшего города минимально
    Только при соблюдении ОБОИХ условий мы рассматриваем точку
    На каждой итерации мы будем находить все более оптимальные точки.
    Таким образом при переборе всех точек мы найдем оптимальную
    */
    for (int i = 0; i < point_x_pos.size(); i++) {                                                                  //пробегаемся по всем точкам. Условия рассматриваются ОДНОВРЕМЕННО с помощью логического AND ( логического и)   
        if ((dist_to_city(point_x_pos[i], point_y_pos[i], city_x_pos, city_y_pos) <= min_dist_p_to_c) &&            //условие того, что расстояние до города минимально
            (dist_to_barier(point_x_pos[i], point_y_pos[i], barrier_x_pos, barrier_y_pos) >= max_dist_p_to_b))      //условие того, что расстояние до препятствия максимально
            //в условиях приведенных выше используется условия меньше/больше ИЛИ РАВНО
            //это сделаю потому, что одна коор-та мождет совпадать, а вторая будет подходить лучше
        {
            //сюда мы попадаем только если точка подходит по вышеописанным условиям
            //если точка удовлетворяет условиям, то определяем новое минимальное расстояние до города
            //и максимально до препятствия. таким образом мы найдем оптимальную точку
            //таким образом мы на каждой итерации сужаем условия подходящих точек (по сути это и есть твой эвристический алгоритм)
            min_dist_p_to_c = dist_to_city(point_x_pos[i], point_y_pos[i], city_x_pos, city_y_pos);                 //минимальное расстояние до города становится равно новому минимальному расстоянию
            max_dist_p_to_b = dist_to_barier(point_x_pos[i], point_y_pos[i], barrier_x_pos, barrier_y_pos);         //максимальное расстояние до ближайшего препятствия равно новому макс расстоянию
            p_opt_x = point_x_pos[i];                                                                               //если точка подошла по условиям, то запоминаем ее коор-ты
            p_opt_y = point_y_pos[i];
        }
    }

    double time_algotim = t.elapsed();                                                                              //точка завершающая отсчет времени

    cout << endl << "Координаты оптимальной точки: " << p_opt_x << " " << p_opt_y;                                  //выводим в консоль коор-ты найденной оптимальной точки

    cout <<endl<<"Расстояние от точки до ближайшего города: "<< min_dist_p_to_c;                                    //выводим в консоль расстояние от найденой оптимальной точки до ближайшего  города
    cout <<endl<<"Расстояние от точки до ближайшего препятствия: " << max_dist_p_to_b;                              //выводим в консоль расстояние от найденой оптимальной точки до ближайшего  препятствия
    cout <<endl<<"Время выполнения алгоритма : " << time_algotim * 100000000 << " нс" << endl;                      //выводим время, затраченное на выполнение алгоритма умножая на некий коэффициент 
                                                                                                                    //(потому что я не помню, в каких единицах оно измеряется =))0) ). Выводится в наносекундах
    
    Lboard[p_opt_x][p_opt_y] = '*';                                                                                 //помечаем на ДРП найденную оптимальную точку специальным символом
    Sboard[p_opt_x][p_opt_y] = '*';                                                                                                       

    Print_newDRP(Sboard);                                                                                           //функция преобразующая ДРП символьного вида в ДРП цифрового вида (это нужно для дальнейшей визуализации)                 
                                                                                                                    //эта функция описана в другом файле

    //кусок отвечающей за корректную работу графики
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
    glutInitWindowPosition(100, 100);
    glutInitWindowSize(1000, 1000);                                                                                 //размер выводимого окна
    glutCreateWindow("Даня");                                                                                       //название окна
    glEnable(GL_DEPTH_TEST);
    glClearColor(0, 0, 0, 1);
    glutReshapeFunc(reshape);                                                                                       //рендеринг
    glutDisplayFunc(RenderScene);                                                                                   //основаня (головная) функция отрисовки графики (она писана в пользовательской библиотеке)
    glutKeyboardFunc(Read_kb);                                                                                      //функция отклика графики на клавиатуру
    glutSpecialFunc(ReadSpec);                                                                                      //тоже клава
    glutMainLoop();
    return 0;                                                                                                       //значение возвращаемое главной функцикей програмы (main). Если в программе будут ошибки, то значение будет не 0.
}                                                                                                                   //конец главной функции